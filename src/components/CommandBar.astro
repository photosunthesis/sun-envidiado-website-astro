---
const baseYear = 2025;
const now = new Date();
const currentYear = now.getFullYear();
const copyright =
  currentYear <= baseYear
    ? `© ${baseYear} Sun Envidiado`
    : `© ${baseYear} - ${currentYear} Sun Envidiado`;
---

<div class="command-bar" role="region" aria-label="Command bar">
  <div class="command-bar-inner">
    <div id="vim-error" class="vim-error-inline" role="status" aria-live="polite"></div>

    <span class="cmd-wrapper">
      <input
        id="site-command-input"
        class="cmd-input"
        type="text"
        placeholder="Type a command (e.g. :home, :back)"
        aria-label="Site command input"
        autocomplete="off"
        spellcheck="false"
      />
      <span id="cmd-cursor" class="cmd-cursor" aria-hidden="true"></span>
    </span>

    <div id="cmd-right" class="cmd-right hide-on-mobile" aria-hidden="true">{copyright}</div>
  </div>
</div>

<script>
  const input = document.querySelector<HTMLInputElement>('#site-command-input');
  const vimError = document.querySelector<HTMLElement>('#vim-error');
  const cursor = document.querySelector<HTMLElement>('#cmd-cursor');
  let suppressInputHide = false; // used to prevent programmatic input.value changes from hiding the error

  const showVimError = (text: string) => {
    if (!vimError || !input) return;
    input.closest('.command-bar')?.classList.add('error');
    vimError.textContent = `ERROR: "${text}" is not a valid command`;
  };

  const hideVimError = () => {
    if (!vimError || !input) return;
    input.closest('.command-bar')?.classList.remove('error');
    vimError.textContent = '';
  };

  // hide native caret — prefer custom block cursor
  const hideNativeCaret = () => {
    if (!input) return;
    input.style.caretColor = 'transparent';
  };

  const measureTextWidth = (text: string) => {
    if (!input) return 0;
    const span = document.createElement('span');
    span.style.cssText = `visibility:hidden;position:absolute;white-space:pre;font:${getComputedStyle(input).font}`;
    span.textContent = text || '';
    document.body.appendChild(span);
    const w = span.getBoundingClientRect().width;
    document.body.removeChild(span);
    return w;
  };

  const positionCursor = () => {
    if (!cursor || !input) return;
    const value = input.value || '';
    const textWidth = measureTextWidth(value);
    const style = getComputedStyle(input);
    const paddingLeft = parseFloat(style.paddingLeft) || 0;
    const left = (input.offsetLeft || 0) + paddingLeft + textWidth - (input.scrollLeft || 0);
    cursor.style.left = `${left}px`;

    const lastChar = value.slice(-1) || ' ';
    const charWidth = Math.max(1, Math.round(measureTextWidth(lastChar)));
    const fallbackWidth = (parseFloat(style.fontSize) || 16) * 0.6;
    const caretWidth = Math.max(charWidth, fallbackWidth);
    cursor.style.width = `${caretWidth}px`;
    cursor.style.height = `${input.clientHeight}px`;
    cursor.style.display = document.activeElement === input ? 'block' : 'none';
  };

  // reposition cursor on input, focus, and window resize
  input?.addEventListener('input', () => {
    hideVimError();
    positionCursor();
  });

  input?.addEventListener('focus', () => {
    hideVimError();
    hideNativeCaret();
    positionCursor();
    cursor?.classList.add('visible');
    try {
      input.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    } catch {
      /* ignore */
    }
  });

  input?.addEventListener('blur', () => {
    cursor?.classList.remove('visible');
    if (cursor) cursor.style.display = 'none';
  });

  window.addEventListener('resize', positionCursor);

  // Make the entire command bar clickable — focus input when the bar is clicked.
  if (input) {
    const bar = input.closest('.command-bar');
    if (bar) {
      bar.addEventListener('click', (ev) => {
        if (ev.target === input) return;
        if (document.activeElement === input) {
          input.blur();
          hideVimError();
          return;
        }
        input.focus();
        setTimeout(() => input.setSelectionRange(input.value.length, input.value.length), 0);
      });
    }
  }

  function handleCommand(raw: string) {
    if (!raw) return;
    const val = raw.trim();
    if (!val.startsWith(':')) {
      showVimError(val);
      return;
    }
    const token = val.slice(1);
    if (!token) {
      showVimError(val);
      return;
    }
    const cmd = token.toLowerCase();

    // Support explicit blog selection syntax like `:blog[0]` (case-insensitive)
    // Only works when on the blog page (/blog or /blog/)
    const blogMatch = cmd.match(/^blog\[(\d+)\]$/i);
    if (blogMatch) {
      const currentPath = window.location.pathname;
      const onBlogPage = currentPath === '/blog' || currentPath === '/blog/';

      if (!onBlogPage) {
        showVimError(val);
        return;
      }

      // Use 0-based indexing directly (blog posts are now 0-indexed)
      const idx = Number(blogMatch[1]);
      const el = document.querySelector<HTMLElement>(`[data-blog-index="${idx}"]`);
      if (el) {
        const url = el.getAttribute('data-blog-url');
        if (url) {
          window.location.href = url;
          return;
        }
      }
      showVimError(val);
      return;
    }

    // If we're on the blog index and the command is just a number, treat it as selecting that indexed post
    // Use 0-based indexing directly
    const numeric = Number(cmd);
    if (!Number.isNaN(numeric) && window.location.pathname.startsWith('/blog')) {
      const el = document.querySelector<HTMLElement>(`[data-blog-index="${numeric}"]`);
      if (el) {
        const url = el.getAttribute('data-blog-url');
        if (url) {
          window.location.href = url;
          return;
        }
      }
      showVimError(val);
      return;
    }

    // helpers to enable/disable CRT and persist preference
    function setCrtEnabled(enabled: boolean) {
      // allow an external environment to override CRT preference
      try {
        window.__setCrtPreference?.(enabled);
        // If the external handler exists we assume it managed persistence
        if (typeof window.__setCrtPreference === 'function') return;
      } catch {
        // ignore and fall back
      }

      try {
        const container = document.querySelector<HTMLElement>('#crt-overlay-container');
        if (enabled) {
          container?.classList.add('crt-enabled');
          document.body?.classList.add('crt-text-ca');
          localStorage.setItem('crt-enabled', '1');
        } else {
          container?.classList.remove('crt-enabled');
          document.body?.classList.remove('crt-text-ca');
          localStorage.setItem('crt-enabled', '0');
        }
      } catch {
        // storage blocked — still toggle classes for UI
        const container = document.querySelector<HTMLElement>('#crt-overlay-container');
        if (enabled) {
          container?.classList.add('crt-enabled');
          document.body?.classList.add('crt-text-ca');
        } else {
          container?.classList.remove('crt-enabled');
          document.body?.classList.remove('crt-text-ca');
        }
      }
    }

    switch (cmd) {
      case 'home':
        window.location.href = '/';
        break;
      case 'about':
        window.location.href = '/about';
        break;
      case 'contact':
        window.location.href = '/contact';
        break;
      case 'work':
        window.location.href = '/work';
        break;
      case 'blog':
        window.location.href = '/blog';
        break;
      case 'back':
        window.history.back();
        break;
      case 'crt':
        setCrtEnabled(true);
        break;

      default:
        showVimError(val);
    }
  }

  // Enter to execute, Escape to clear and hide error
  if (input) {
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        handleCommand(input.value);
        suppressInputHide = true;
        input.value = '';
        positionCursor();
        input.blur();
      } else if (e.key === 'Escape') {
        input.value = '';
        input.blur();
        hideVimError();
      }
    });

    // When user types again, hide the error state (unless suppressed by programmatic clear)
    input.addEventListener('input', () => {
      if (suppressInputHide) {
        suppressInputHide = false;
        return;
      }
      hideVimError();
    });
  }

  // While the error is visible, pressing any normal key should clear it and focus the input
  window.addEventListener('keydown', (ev) => {
    if (!vimError || !input) return;
    const bar = input.closest('.command-bar');
    if (bar && bar.classList.contains('error')) {
      if (ev.key.length === 1 || ['Backspace', 'Escape'].includes(ev.key)) {
        hideVimError();
        input.focus();
      }
    }
  });

  // Global shortcut: press ':' to focus the input (unless typing in another field)
  window.addEventListener('keydown', (e) => {
    if (e.key !== ':') return;
    const active = document.activeElement;
    const activeTag = active ? active.tagName || '' : '';
    if (activeTag !== 'INPUT' && activeTag !== 'TEXTAREA') {
      e.preventDefault();
      input?.focus();
      setTimeout(() => {
        if (input) input.setSelectionRange(input.value.length, input.value.length);
      }, 0);
    }
  });

  // Prevent the command bar input from stealing scroll when focused on mobile
  if (input) {
    input.addEventListener('focus', () => {
      document.body.classList.add('command-bar-focused');
    });
    input.addEventListener('blur', () => {
      document.body.classList.remove('command-bar-focused');
    });
  }

  // CRT preference helpers (moved here so external script is not required)
  // ...existing code...
  const CRT_PREFERENCE_KEY = 'crt-enabled';

  const getCookie = (key: string): string | null => {
    try {
      const match = document.cookie.match(new RegExp('(?:^|; )' + key + '=([^;]+)'));
      return match ? decodeURIComponent(match[1]) : null;
    } catch {
      return null;
    }
  };

  const setCookie = (key: string, value: string, days = 365) => {
    try {
      const maxAge = 60 * 60 * 24 * days;
      document.cookie = `${key}=${encodeURIComponent(value)}; path=/; max-age=${maxAge}; samesite=lax`;
    } catch {
      // ignore
    }
  };

  const getPreference = (): string | null => {
    try {
      const v = localStorage.getItem(CRT_PREFERENCE_KEY);
      if (v !== null) return v;
    } catch {
      // localStorage inaccessible
    }
    return getCookie(CRT_PREFERENCE_KEY);
  };

  const setPreference = (val: string) => {
    try {
      localStorage.setItem(CRT_PREFERENCE_KEY, val);
    } catch {
      // ignore
    }
    setCookie(CRT_PREFERENCE_KEY, val);
  };

  const applyPreferenceToDom = (val: string | null) => {
    try {
      if (val === '1') {
        document.body.classList.add('crt-text-ca');
        const container = document.querySelector<HTMLElement>('#crt-overlay-container');
        if (container) container.classList.add('crt-enabled');
        else
          document.addEventListener('DOMContentLoaded', () => {
            document.querySelector('#crt-overlay-container')?.classList.add('crt-enabled');
          });
      } else if (val === '0') {
        document.body.classList.remove('crt-text-ca');
        document.querySelector('#crt-overlay-container')?.classList.remove('crt-enabled');
      }
    } catch {
      // ignore
    }
  };

  const exposeWindowSetter = () => {
    try {
      window.__setCrtPreference = (enabled: boolean) => {
        setPreference(enabled ? '1' : '0');
        if (enabled) {
          document.body.classList.add('crt-text-ca');
          document.querySelector('#crt-overlay-container')?.classList.add('crt-enabled');
        } else {
          document.body.classList.remove('crt-text-ca');
          document.querySelector('#crt-overlay-container')?.classList.remove('crt-enabled');
        }
      };
    } catch {
      // ignore
    }
  };

  // Initialize: expose API and apply stored preference (if any)
  try {
    exposeWindowSetter();
    const v = getPreference();
    applyPreferenceToDom(v);
  } catch {
    // ignore initialization errors
  }

  // Augment Window with the small optional API exposed by this script
  declare global {
    interface Window {
      __runSiteCommand?: (raw: string, execute?: boolean) => void;
      __setCrtPreference?: (enabled: boolean) => void;
    }
  }

  // Expose a small API so other parts of the page can programmatically insert or execute commands.
  window.__runSiteCommand = (raw: string, execute = false) => {
    if (!raw || !input) return;
    const val = raw.trim();
    if (execute) {
      handleCommand(val);
      return;
    }
    input.value = val;
    positionCursor();
    input.focus();
  };
</script>

<style lang="scss">
  /* Global command bar variables are assumed to be available or we use values */

  .cmd-input {
    outline: none;
    min-width: 2ch;
    background: transparent;
    border: none;
    /* Let inputs inherit color so inside .command-bar they use the dark page background color */
    color: inherit;
    font-family: inherit;
    font-size: 1rem;
    /* hide native caret so the custom rectangular cursor is used */
    caret-color: transparent;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    padding: 0.1rem 0.25rem;
    width: 100%;
    max-width: min(60ch, 90vw);

    &::placeholder {
      color: rgba(
        9,
        9,
        11,
        0.3
      ); /* using --background-rgb default since we can't easily access scss vars unless imported */
      /* actually, we can use css vars */
      color: rgba(var(--background-rgb), 0.3);
      opacity: 1;
    }
  }

  /* Hide the placeholder while in error state so it doesn't overlap the error message */
  .command-bar.error .cmd-input::placeholder {
    color: transparent !important;
    opacity: 0 !important;
  }

  .cmd-feedback {
    margin-left: 1rem;
    color: var(--comment);
    font-size: 0.95rem;
  }

  .cmd-wrapper {
    position: relative;
    display: flex;
    flex: 1 1 auto;
    align-items: center;
    margin-left: -8px;
  }

  .command-bar {
    /* Make the command bar full-width and stick to the bottom while
       respecting device safe-area insets (iOS notch / bottom UI). */
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 10000;
    display: block;
    width: 100vw;
    /* full-bleed background; inner wrapper provides padding */
    padding: 0;
    /* inner handles padding including safe-area */
    background: var(--foreground);
    /* foreground becomes background */
    color: var(--background);
    /* text uses page background color */
    backdrop-filter: none;
    box-shadow: 0 -1px 0 rgba(0, 0, 0, 0.2);
    /* Ensure it sits above other content without overlapping interactive elements */
    -webkit-tap-highlight-color: transparent;
  }

  .command-bar-inner {
    display: flex;
    align-items: center;
    padding: 0.35rem 0.75rem calc(env(safe-area-inset-bottom, 0) + 0.35rem);
  }

  /* Left area inside the command bar for small persistent info (copyright etc) */
  .command-bar .cmd-right {
    margin-left: 1rem;
    color: rgba(var(--background-rgb), 0.3);
    /* match the input placeholder color */
    font-size: 0.95rem;
    white-space: nowrap;
    opacity: 1;
    flex: 0 0 auto;
  }

  /* Hide the right copyright when the command bar is in error state so it doesn't overlap the error text */
  .command-bar.error .cmd-right {
    display: none;
  }

  .cmd-cursor {
    position: absolute;
    top: 0;
    left: 0;
    /* default background; overridden in context-sensitive places */
    background: var(--foreground);
    opacity: 0.95;
    display: none;
    transform: translateY(0.1em);
    border-radius: 2px;
    pointer-events: none;
    z-index: 10001;
    animation: cmd-cursor-blink 1s steps(1) infinite;
  }

  /* Ensure the block cursor inside the command bar uses the text color (currentColor)
     so it contrasts against the bar background */
  .command-bar .cmd-cursor {
    background: currentColor;
  }

  /* Ensure inputs inside the command bar inherit the visible color, and the block cursor sits above the input text */
  .command-bar .cmd-input {
    color: currentColor;
    background: transparent;
    position: relative;
    z-index: 1;
  }

  .command-bar .cmd-cursor {
    z-index: 10002;
  }

  /* This was a global class possibly applied to body */
  :global(.command-bar-focused) {
    overscroll-behavior: contain;
  }

  .cmd-cursor {
    display: inline-block;
    height: 1em;
  }

  /* Error state for command bar: use red background and show error text inline */
  .command-bar.error {
    background: var(--red);
    color: var(--background);
    /* keep text readable */
  }

  .vim-error-inline {
    display: inline-block;
    font-size: 0.95rem;
    color: inherit;
    margin-left: 0.5rem;
  }

  @keyframes cmd-cursor-blink {
    50% {
      opacity: 0;
    }
  }

  .hide-on-mobile {
    display: block;

    @media (max-width: 480px) {
      display: none !important;
    }
  }
</style>
