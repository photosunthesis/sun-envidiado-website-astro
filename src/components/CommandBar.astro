<div class="command-bar" role="region" aria-label="Command bar">
  <div class="command-bar-inner">
    <div
      id="vim-error"
      class="vim-error-inline"
      role="status"
      aria-live="polite"
    >
    </div>

    <span class="cmd-wrapper">
      <input
        id="site-command-input"
        class="cmd-input"
        type="text"
        placeholder="Type a command (e.g. :home, :back)"
        aria-label="Site command input"
        autocomplete="off"
        spellcheck="false"
      />
      <span id="cmd-cursor" class="cmd-cursor" aria-hidden="true"></span>
    </span>
  </div>
</div>

<script>
  const input = document.querySelector(
    "#site-command-input",
  ) as HTMLInputElement | null;
  const vimError = document.querySelector("#vim-error") as HTMLElement | null;
  let suppressInputHide = false; // used to prevent programmatic input.value changes from hiding the error

  const showVimError = (text: string) => {
    if (!vimError || !input) return;
    input.closest(".command-bar")?.classList.add("error");
    vimError.textContent = `ERROR: "${text}" is not a valid command`;
  };

  const hideVimError = () => {
    if (!vimError || !input) return;
    input.closest(".command-bar")?.classList.remove("error");
    vimError.textContent = "";
  };

  // Custom rectangular block cursor (like Vim)
  const cursor = document.querySelector("#cmd-cursor") as HTMLElement | null;
  // hide native caret — prefer custom block cursor
  const hideNativeCaret = () =>
    input && (input.style.caretColor = "transparent");

  const measureTextWidth = (text: string) => {
    if (!input) return 0;
    const span = document.createElement("span");
    span.style.cssText = `visibility:hidden;position:absolute;white-space:pre;font:${getComputedStyle(input).font}`;
    span.textContent = text || "";
    document.body.appendChild(span);
    const w = span.getBoundingClientRect().width;
    document.body.removeChild(span);
    return w;
  };

  const positionCursor = () => {
    if (!cursor || !input) return;
    const value = input.value || "";
    const textWidth = measureTextWidth(value);
    const style = getComputedStyle(input);
    const paddingLeft = parseFloat(style.paddingLeft) || 0;
    const left =
      (input.offsetLeft || 0) +
      paddingLeft +
      textWidth -
      (input.scrollLeft || 0);
    cursor.style.left = `${left}px`;

    const lastChar = value.slice(-1) || " ";
    const charWidth = Math.max(1, Math.round(measureTextWidth(lastChar)));
    const fallbackWidth = (parseFloat(style.fontSize) || 16) * 0.6;
    const caretWidth = Math.max(charWidth, fallbackWidth);
    cursor.style.width = `${caretWidth}px`;
    cursor.style.height = `${input.clientHeight}px`;
    cursor.style.display = document.activeElement === input ? "block" : "none";
  };

  // reposition cursor on input, focus, and window resize
  input?.addEventListener("input", () => {
    hideVimError();
    positionCursor();
  });

  input?.addEventListener("focus", () => {
    hideVimError();
    hideNativeCaret();
    positionCursor();
    cursor?.classList.add("visible");
    try {
      input.scrollIntoView({ behavior: "smooth", block: "nearest" });
    } catch {
      /* ignore */
    }
  });

  input?.addEventListener("blur", () => {
    cursor?.classList.remove("visible");
    if (cursor) cursor.style.display = "none";
  });

  window.addEventListener("resize", positionCursor);

  // Make the entire command bar clickable — focus input when the bar is clicked.
  // Use `click` instead of pointer events so we don't interfere with scrolling on mobile.
  if (input) {
    const bar = input.closest(".command-bar");
    if (bar) {
      bar.addEventListener("click", (ev) => {
        // If user clicked directly on the input, let the default happen
        if (ev.target === input) return;
        // If the input is currently focused, clicking the bar will unfocus it
        if (document.activeElement === input) {
          input.blur();
          hideVimError();
          return;
        }
        // Focus the input (do not preventDefault so scrolling isn't blocked)
        input.focus();
        // put caret at end
        setTimeout(
          () => input.setSelectionRange(input.value.length, input.value.length),
          0,
        );
      });
    }
  }

  function handleCommand(raw: string) {
    if (!raw) return;
    const val = raw.trim();
    if (!val.startsWith(":")) {
      showVimError(val);
      return;
    }
    const token = val.slice(1);
    if (!token) {
      showVimError(val);
      return;
    }
    const cmd = token.toLowerCase();

    // Support explicit blog selection syntax like `:blog[1]` (case-insensitive)
    const blogMatch = cmd.match(/^blog\[(\d+)\]$/i);
    if (blogMatch) {
      const idx = Number(blogMatch[1]);
      const el = document.querySelector(`[data-blog-index="${idx}"]`);
      if (el && el instanceof HTMLElement) {
        const url = el.getAttribute("data-blog-url");
        if (url) {
          window.location.href = url;
          return;
        }
      }
      showVimError(val);
      return;
    }

    // If we're on the blog index and the command is just a number, treat it as selecting that indexed post
    const numeric = Number(cmd);
    if (
      !Number.isNaN(numeric) &&
      typeof window !== "undefined" &&
      window.location.pathname.startsWith("/blog")
    ) {
      const el = document.querySelector(`[data-blog-index="${numeric}"]`);
      if (el && el instanceof HTMLElement) {
        const url = el.getAttribute("data-blog-url");
        if (url) {
          window.location.href = url;
          return;
        }
      }
      showVimError(val);
      return;
    }

    // helpers to enable/disable CRT and persist preference
    function setCrtEnabled(enabled: boolean) {
      try {
        const api: any = globalThis;
        if (typeof api.__setCrtPreference === "function") {
          api.__setCrtPreference(enabled);
          return;
        }
      } catch {
        // ignore and fall back
      }

      try {
        const container = document.querySelector("#crt-overlay-container");
        if (enabled) {
          container?.classList.add("crt-enabled");
          document.body?.classList.add("crt-text-ca");
          localStorage.setItem("crt-enabled", "1");
        } else {
          container?.classList.remove("crt-enabled");
          document.body?.classList.remove("crt-text-ca");
          localStorage.setItem("crt-enabled", "0");
        }
      } catch {
        // storage blocked — still toggle classes for UI
        const container = document.querySelector("#crt-overlay-container");
        if (enabled) {
          container?.classList.add("crt-enabled");
          document.body?.classList.add("crt-text-ca");
        } else {
          container?.classList.remove("crt-enabled");
          document.body?.classList.remove("crt-text-ca");
        }
      }
    }

    switch (cmd) {
      case "home":
        window.location.href = "/";
        break;
      case "about":
        window.location.href = "/about";
        break;
      case "contact":
        window.location.href = "/contact";
        break;
      case "blog":
        window.location.href = "/blog";
        break;
      case "back":
        window.history.back();
        break;
      case "crt":
        setCrtEnabled(true);
        break;
      case "no-crt":
        setCrtEnabled(false);
        break;
      default:
        // Unknown command -> show error inline by changing the bar background
        showVimError(val);
    }
  }

  // Enter to execute, Escape to clear and hide error
  if (input) {
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        // Execute command
        handleCommand(input.value);
        // Clear input on Enter as requested, but avoid hiding the error immediately
        suppressInputHide = true;
        input.value = "";
        // reposition cursor after clearing
        positionCursor();
        input.blur();
      } else if (e.key === "Escape") {
        input.value = "";
        input.blur();
        hideVimError();
      }
    });

    // When user types again, hide the error state (unless suppressed by programmatic clear)
    input.addEventListener("input", () => {
      if (suppressInputHide) {
        // reset the flag and don't hide the error this round
        suppressInputHide = false;
        return;
      }
      hideVimError();
    });
  }

  // While the error is visible, pressing any normal key should clear it and focus the input
  window.addEventListener("keydown", (ev) => {
    if (!vimError || !input) return;
    const bar = input.closest(".command-bar");
    if (bar && bar.classList.contains("error")) {
      if (ev.key.length === 1 || ["Backspace", "Escape"].includes(ev.key)) {
        hideVimError();
        input.focus();
      }
    }
  });

  // Global shortcut: press ':' to focus the input (unless typing in another field)
  window.addEventListener("keydown", (e) => {
    if (e.key !== ":") return;
    const active = document.activeElement;
    const activeTag = active ? active.tagName || "" : "";
    if (activeTag !== "INPUT" && activeTag !== "TEXTAREA") {
      e.preventDefault();
      input && input.focus();
      setTimeout(
        () =>
          input &&
          input.setSelectionRange(input.value.length, input.value.length),
        0,
      );
    }
  });

  // Prevent the command bar input from stealing scroll when focused on mobile
  if (input) {
    input.addEventListener("focus", () => {
      document.body.classList.add("command-bar-focused");
    });
    input.addEventListener("blur", () => {
      document.body.classList.remove("command-bar-focused");
    });
  }

  // Expose a small API so other parts of the page can programmatically insert or
  // execute commands. Usage:
  //   window.__runSiteCommand(':about')         -> inserts and focuses input
  //   window.__runSiteCommand(':about', true)   -> executes immediately
  // This uses the same `handleCommand` logic so behavior is consistent.
  try {
    (globalThis as any).__runSiteCommand = (raw: string, execute = false) => {
      if (!raw || !input) return;
      const val = raw.trim();
      if (execute) {
        handleCommand(val);
        return;
      }
      // insert into input and focus
      input.value = val;
      positionCursor();
      input.focus();
    };
  } catch {
    // ignore if environment prevents assignment
  }
</script>
