---
// Client-rendered component: simple command input at the bottom
---

<div class="command-bar" role="region" aria-label="Command bar">
  <!-- removed static colon so users must type ':' themselves -->
  <span class="cmd-wrapper">
    <input
      id="site-command-input"
      class="cmd-input"
      type="text"
      aria-label="Site command input"
      autocomplete="off"
      spellcheck="false"
    />
    <span id="cmd-cursor" class="cmd-cursor" aria-hidden="true"></span>
  </span>

  <!-- Vim-like error box (hidden by default). Shows messages like: "E492: Not an editor command: foo" -->
  <div
    id="vim-error"
    class="vim-error"
    role="alert"
    aria-live="assertive"
    style="display:none"
  >
  </div>

  <script type="module">
    const input = document.getElementById("site-command-input");
    const vimError = document.getElementById("vim-error");
    let suppressInputHide = false; // used to prevent programmatic input.value changes from hiding the error

    function showVimError(text) {
      if (!vimError) return;
      // Use the classic Vim code for unknown command
      vimError.textContent = `ERROR: "${text}" is not a valid command`;
      vimError.style.display = "block";
    }

    function hideVimError() {
      if (!vimError) return;
      vimError.style.display = "none";
      vimError.textContent = "";
    }

    // Custom rectangular block cursor (like Vim)
    const cursor = document.getElementById("cmd-cursor");
    // hidden native caret
    const hideNativeCaret = () => {
      input.style.caretColor = "transparent";
    };

    function measureTextWidth(text) {
      // create a temporary span to measure text width with same font
      const span = document.createElement("span");
      span.style.visibility = "hidden";
      span.style.position = "absolute";
      span.style.whiteSpace = "pre";
      span.style.font = getComputedStyle(input).font;
      span.textContent = text || "";
      document.body.appendChild(span);
      const w = span.getBoundingClientRect().width;
      document.body.removeChild(span);
      return w;
    }

    function positionCursor() {
      if (!cursor) return;
      const wrapper = cursor.parentElement;
      if (!wrapper) return;
      // measure the input's value width
      const value = input.value || "";
      const textForMeasure = value;
      const textWidth = measureTextWidth(textForMeasure);
      const style = getComputedStyle(input);
      const paddingLeft = parseFloat(style.paddingLeft) || 0;
      const scrollLeft = input.scrollLeft || 0;
      // input offset relative to wrapper
      const inputOffsetLeft = input.offsetLeft || 0;
      // left position relative to wrapper
      const left = inputOffsetLeft + paddingLeft + textWidth - scrollLeft;
      cursor.style.left = `${left}px`;

      // caret width: measure last character if present, otherwise 0.8ch
      const lastChar = value.slice(-1) || " ";
      const charWidth = Math.max(1, Math.round(measureTextWidth(lastChar)));
      // fallback to 0.6em if measurement fails
      const fallbackWidth = (parseFloat(style.fontSize) || 16) * 0.6;
      const caretWidth = Math.max(charWidth, fallbackWidth);
      cursor.style.width = `${caretWidth}px`;

      cursor.style.height = `${input.clientHeight}px`;
      cursor.style.display =
        document.activeElement === input ? "block" : "none";
    }

    // reposition cursor on input, focus, and window resize
    input.addEventListener("input", () => {
      hideVimError();
      positionCursor();
    });
    input.addEventListener("focus", () => {
      hideVimError();
      hideNativeCaret();
      positionCursor();
      cursor.classList.add("visible");
      // ensure the input is visible on mobile when focused but don't cover too much
      try {
        input.scrollIntoView({ behavior: "smooth", block: "nearest" });
      } catch (e) {
        /* ignore on older browsers */
      }
    });
    input.addEventListener("blur", () => {
      cursor.classList.remove("visible");
      cursor.style.display = "none";
    });
    window.addEventListener("resize", positionCursor);
    // Make the entire command bar tappable — focus input when the bar is clicked/tapped
    const bar = input.closest(".command-bar");
    if (bar) {
      bar.addEventListener("pointerdown", (ev) => {
        // If user clicked directly on the input, let the default happen
        if (ev.target === input) return;
        // If the input is currently focused, tapping the bar will unfocus it
        if (document.activeElement === input) {
          input.blur();
          hideVimError();
          return;
        }
        ev.preventDefault();
        input.focus();
        // put caret at end
        setTimeout(
          () => input.setSelectionRange(input.value.length, input.value.length),
          0,
        );
      });
    }

    // Global tap: toggle command bar focus when tapping non-interactive areas
    // Use capture so we see taps before other handlers which might steal focus
    document.addEventListener(
      "pointerdown",
      (ev) => {
        const t = ev.target;
        if (!t || !(t instanceof Element)) return;
        // If tap landed inside the command bar, let the bar handler manage it
        if (t.closest(".command-bar")) return;
        // Ignore taps on interactive elements (links, inputs, buttons, labels, selects, contenteditable)
        if (
          t.closest(
            "a, button, input, textarea, select, label, [contenteditable]",
          )
        )
          return;

        if (document.activeElement === input) {
          // If input is focused, tapping outside unfocuses it
          input.blur();
          hideVimError();
        } else {
          // If input is not focused, tapping outside focuses it
          // Schedule focus so other event handlers don't immediately steal it
          setTimeout(() => {
            input.focus();
            input.setSelectionRange(input.value.length, input.value.length);
          }, 0);
        }
      },
      { capture: true },
    );

    function handleCommand(raw) {
      if (!raw) return;
      const val = raw.trim();
      const token = val.startsWith(":") ? val.slice(1) : val;

      if (!token) return;

      const cmd = token.toLowerCase();

      // Support explicit blog selection syntax like `blog[1]` or `b[1]` (case-insensitive)
      const blogMatch = cmd.match(/^(?:blog|b)\[(\d+)\]$/i);
      if (blogMatch) {
        const idx = Number(blogMatch[1]);
        const el = document.querySelector(`[data-blog-index="${idx}"]`);
        if (el && el instanceof HTMLElement) {
          const url = el.getAttribute("data-blog-url");
          if (url) {
            window.location.href = url;
            return;
          }
        }
        showVimError(cmd);
        return;
      }

      // If we're on the blog index and the command is just a number, treat it as selecting that indexed post
      const numeric = Number(cmd);
      if (
        !Number.isNaN(numeric) &&
        typeof window !== "undefined" &&
        window.location.pathname.startsWith("/blog")
      ) {
        const el = document.querySelector(`[data-blog-index="${numeric}"]`);
        if (el && el instanceof HTMLElement) {
          const url = el.getAttribute("data-blog-url");
          if (url) {
            window.location.href = url;
            return;
          }
        }
        showVimError(cmd);
        return;
      }

      switch (cmd) {
        case "home":
          window.location.href = "/";
          break;
        case "about":
          window.location.href = "/about";
          break;
        case "contact":
          window.location.href = "/contact";
          break;
        case "blog":
          window.location.href = "/blog";
          break;
        case "back":
          window.history.back();
          break;
        default:
          // Unknown command -> show Vim-like error
          showVimError(cmd || val);
      }
    }

    // Enter to execute, Escape to clear and hide error
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        // Execute command
        handleCommand(input.value);
        // Clear input on Enter as requested, but avoid hiding the error immediately
        suppressInputHide = true;
        input.value = "";
        // reposition cursor after clearing
        positionCursor();
        input.blur();
      } else if (e.key === "Escape") {
        input.value = "";
        input.blur();
        hideVimError();
      }
    });

    // When user types again, hide the Vim error box (unless suppressed by programmatic clear)
    input.addEventListener("input", () => {
      if (suppressInputHide) {
        // reset the flag and don't hide the error this round
        suppressInputHide = false;
        return;
      }
      hideVimError();
    });

    // If the vim-error element is clicked/tapped, focus input and hide the error
    if (vimError) {
      vimError.addEventListener("pointerdown", (ev) => {
        ev.preventDefault();
        hideVimError();
        input.focus();
        setTimeout(
          () => input.setSelectionRange(input.value.length, input.value.length),
          0,
        );
      });
    }

    // While the vim error is visible, pressing any normal key should clear it and focus the input
    window.addEventListener("keydown", (ev) => {
      if (!vimError) return;
      if (vimError.style.display === "block") {
        // If it's a character key or Backspace/Escape, hide and focus.
        // NOTE: don't treat Enter as a dismiss key — Enter should trigger/show the error.
        if (ev.key.length === 1 || ["Backspace", "Escape"].includes(ev.key)) {
          hideVimError();
          input.focus();
        }
      }
    });

    // Global shortcut: press ':' to focus the input (unless typing in another field)
    window.addEventListener("keydown", (e) => {
      if (
        e.key === ":" &&
        document.activeElement.tagName !== "INPUT" &&
        document.activeElement.tagName !== "TEXTAREA"
      ) {
        e.preventDefault();
        input.focus();
        setTimeout(
          () => input.setSelectionRange(input.value.length, input.value.length),
          0,
        );
      }
    });

    // Prevent the command bar input from stealing scroll when focused on mobile
    input.addEventListener("focus", () => {
      document.body.classList.add("command-bar-focused");
    });
    input.addEventListener("blur", () => {
      document.body.classList.remove("command-bar-focused");
    });
  </script>
</div>
