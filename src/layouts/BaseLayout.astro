---
import CommandBar from "../components/CommandBar.astro";
import "../styles/global.css"; // import global styles

const {
  title = "Sun Envidiado",
  description = "Personal website where I share my thoughts about anything and everything.",
  image = "/android-chrome-512x512.png",
  url = Astro.site || "https://sun-envidiado.com",
  type = "website",
  noIndex = false,
  jsonLd = null,
  pubDate = undefined,
  tags = [],
  ...rest
} = Astro.props;

// Preferred canonical origin for the site. Change this to the domain you
// want search engines to index (include protocol, no trailing slash).
// This takes precedence over `Astro.site` for canonical/tag/image URLs.
const preferredOrigin = "https://sun-envidiado.com";

// Normalize site origin (Astro.site can be a URL object in some setups).
// Use `preferredOrigin` as the canonical base; fallback to `Astro.site` if
// preferredOrigin is intentionally left blank.
const siteOrigin =
  preferredOrigin || String(Astro.site || "https://sun-envidiado.com");

// Helper to detect file-like paths (have an extension) so we can
// decide whether to force a trailing slash for directory pages.
/**
 * @param {any} pathname
 */
function looksLikeFilePath(pathname: any) {
  return /\.[a-z0-9]+$/i.test(String(pathname));
}

// Resolve `url` into an absolute canonical URL. Accepts either a full
// absolute URL or a pathname (e.g. "/blog/my-post"). We normalize
// directory-like paths to include a trailing slash so the canonical
// doesn't point to a URL that redirects (common on GitHub Pages).
let canonical;
try {
  // Force canonical URLs to use the preferred origin. Accept either an
  // absolute URL (overrides host) or a pathname (e.g. '/blog/my-post').
  const resolved = new URL(String(url), siteOrigin);
  if (
    !looksLikeFilePath(resolved.pathname) &&
    !resolved.pathname.endsWith("/")
  ) {
    resolved.pathname = resolved.pathname.replace(/\/?$/, "/");
  }
  // Ensure canonical uses the preferred origin exactly (protocol + host).
  // If `url` itself included a different origin, prefer the configured
  // `preferredOrigin` to avoid mixed host canonical values.
  try {
    const canonicalUrl = new URL(
      resolved.pathname + resolved.search + resolved.hash,
      preferredOrigin,
    );
    canonical = canonicalUrl.toString();
  } catch (err) {
    canonical = resolved.toString();
  }
} catch (e) {
  // Fallback: fall back to the original value as a string if URL fails
  canonical = String(url);
}

// Resolve image URLs similarly so OG/twitter images are absolute.
let fullImage;
try {
  // Resolve images against the preferred origin so OG/twitter images always
  // point to the canonical host (avoids cross-host image URLs).
  fullImage = new URL(String(image), siteOrigin).toString();
} catch (e) {
  fullImage = String(image);
}
---

<html lang="en">
  <head>
    <title>{title}</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content={description} />
    <meta
      name="robots"
      content={noIndex ? "noindex, nofollow" : "index, follow"}
    />

    <link rel="canonical" href={canonical} />

    {pubDate && <meta property="article:published_time" content={pubDate} />}
    {
      Array.isArray(tags) &&
        tags.length > 0 &&
        tags.map((tag) => <meta property="article:tag" content={tag} />)
    }

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content={type} />
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    <meta property="og:url" content={canonical} />
    <meta property="og:image" content={fullImage} />

    <!-- Twitter -->
    <meta
      name="twitter:card"
      content={image ? "summary_large_image" : "summary"}
    />
    <meta name="twitter:title" content={title} />
    <meta name="twitter:description" content={description} />
    <meta name="twitter:image" content={fullImage} />

    <!-- Allow pages to inject/override head tags via a named slot -->
    <slot name="seo" />

    <!-- Site resources -->
    <link
      rel="preload"
      href="/fonts/Web437_ToshibaSat_8x14.woff2"
      as="font"
      type="font/woff2"
      crossorigin
    />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />

    {
      jsonLd && (
        <script type="application/ld+json" set:html={JSON.stringify(jsonLd)} />
      )
    }
  </head>
  <body class="vim-root">
    <div class="main-flex-container">
      <aside id="tilde-column" class="tilde-column" aria-hidden="true"></aside>
      <main class="vim-main-content">
        <div class="centered-vim">
          <slot />
        </div>
      </main>
    </div>
    <CommandBar />
  </body>
  <script type="module">
    // Render tildes to fill the document height (covers overflow) and
    // keep the tilde column purely visual (pointer-events: none)
    function renderTildes() {
      const tildeCol = document.getElementById("tilde-column");
      if (!tildeCol) return;
      const style = getComputedStyle(tildeCol);
      const lineHeight = parseFloat(style.lineHeight) || 24;
      // Column is fixed and floats over the page. Use the viewport height so
      // the column always visually fills the screen. Reserve one line at the
      // bottom for the floating command bar.
      const height = window.innerHeight;
      // Reserve 3 lines at the bottom to ensure the floating command bar is
      // not accidentally covered by tilde characters on small viewports.
      const reservedLines = 3;
      const count = Math.max(0, Math.ceil(height / lineHeight) - reservedLines);
      tildeCol.textContent = Array(count).fill("~").join("\n");
    }
    window.addEventListener("resize", renderTildes);
    window.addEventListener("DOMContentLoaded", renderTildes);
  </script>
</html>
